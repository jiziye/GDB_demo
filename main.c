int main(void)
{
    unsigned long long int n, sum;

    n = 1;
    sum = 0;

    while(n <= 100)
    {
        sum = sum + n;
        n = n + 1;
    }

    return 0;
}

/*
编译：
使用 GCC 来编译 main.c，编译的时候使用-g选项，它的目的是向可执行程序中加入调试信息，
包括源代码、符号表等，GDB 需要这些额外的信息来完成调试工作。
使用 GCC 编译源文件：

$ gcc main.c -o main.out -g 

调试：
 1) 启动 GDB 调试器
接下来启动 GDB 并调试 main.out： 

$ gdb main.out -silent 
Reading symbols from /home/mozhiyan/demo/main.out...done.

选项 -silent 用于屏蔽 GDB 的前导信息，否则它会在屏幕上打印一堆免责条款。
启动 GDB 后，它输出的信息表明已经读入了 mian.out 的符号表。
接下来，GDB 会显示自己的提示符(gdb)，提示并等待你输入调试命令。 

 2) gdb -b 选项：设置断点
调试一个程序的时候，应该在我们关注的地方，或者在故障点的前边设置一个断点（Breakpoint），
让程序执行到这里停下来，这样我们就可以慢慢地用别的调试命令进行观察。

在 GDB 中，设置断点的方法很多，包括在 **指定的内存地址处** 设置断点、**在源代码的某一行** 设置断点，
或者**在某个函数的入口处** 设置断点，等等。设置断点的命令是b或者break，在这里我们是将 main 函数的入口处作为断点：

(gdb) b main
Breakpoint 1 at 0x4004f4: file main.c, line 5.

b 命令在执行后返回了断点的具体信息，也就是说，断点（main 函数的入口位置）的内存地址为 0x4004f4，
对应于源文件的第 5 行（也就是说，main 函数位于源文件的第 5 行）。


如果我们用内存地址的方式来设置这个断点，则可以是：

b * 0x4004f4
星号*意味着是以内存地址作为断点的。

如果用源代码行的形式设置这个断点，则可以是

b 5

 3) gdb -r 选项：执行程序
一旦设置了断点，下一步就是用r或者run命令执行被调试的程序，执行后会自动在第一个断点处停下来： 
Starting program: /home/mozhiyan/demo/main.out
[New Thread 1500.0x1e34]
[New Thread 1500.0x2fb8]

Thread 1 hit Breakpoint 1, main () at main.c:5
5     n = 1;

在运行了被调试的程序后，GDB 的输出信息显示程序己经启动，下一个将要执行的语句是第 5 行的n = 1;。
注意，这条语句并没有执行，而仅仅是告诉你，再继续执行程序的话，执行的语句会是它。 

 4) gdb -p 选项：打印变量的值
在当前位置，变量 n 和 sum 己经分配，但并没有开始赋值。此时，这两个变量的值会是多少呢？我们可以使用p或者print命令来分别显示： 
(gdb) p n
$1 = 24
(gdb) p sum
$2 = 140737488347344

GDB 的 p 命令用于打印一个表达式的值，在这里是表达式 n 和 sum。
GDB 先计算表达式的值，并把它保存在一个存储区中，**存储区的名字用$外加数字来表示**，
并且这个数字会随着调试过程的进行而不断递增（这意味着存储区也是不断开辟的）。
以上，第一个 p 命令执行后，GDB 的回应是$1 = 16，意思是表达式 n 的值保存在 $1 中，其内容为 16。

注意，在你的计算机上，变量 n 和 sum 的当前值可能和这里显示的不同。这很好理解，内存是反复使用的，
当一个程序终止后，它占用的内存会分配给其他程序使用；当一个变量不再使用后，它占用的内存也会重新分配，并成为另一个变量。
因为变量 n 和 sum 刚刚分配，还没有往里面保存任何数值，故它们的内容是随机的，是其他程序或者变量用过的垃圾值。

既然 $1 是 GDB 用于保存计算结果的内部存储区的名字，那么我们也可以用 p 命令来打印它：

(gdb) p $1
$3 = 24

 5) gdb -n 选项：单步调试
下面，我们将通过单步执行程序，来看一看变量 n 和 sum 赋值后的值。调试命令n或者next用于继续执行源文件中的下一行。 
(gdb) n
6     sum = 0;

执行 n 命令后，实际执行的是第 5 行n = 1;，GDB 显示下一个即将执行的源代码行，也就是第 6 行的sum = 0;。

因为此时己经往变量 n 写入了 1，所以我们可继续用 p 命令来观察它现在的存储值：

(gdb) p n
$4 = 1

显然，经赋值后，变量 n 的值己经变成 1。

继续执行下一条指令，实际执行的是第 6 行sum = 0。执行后，GDB 停下并显示下一条即将执行的源代码行，也即第 8 行的while (n <= 100)，第 7 行为空行，所以直接跳过了：

(gdb) n
8     while (n <= 100)

刚才执行的语句是往变量 sum 保存数值 0，故我们可以再次用 p 命令来观察变量 sum 现在的存储值，可发现它己经变成 0：

(gdb) p sum
$5 = 0

继续用 n 命令执行下一个源代码行，则将计算 while 语句的控制表达式，并根据该表达式的值决定是否进入循环体，
执行后 GDB  显示下一条即将执行的源代码行是第 10 行：

(gdb) n
10    sum = sum + n;

进入循环体之后，我们想再看看变量 n 和 sum 的当前值。但这次使用 p 命令的方法不一样，
q这次是用花括号将表达式 n 和 sum 围住以形成一个集合。GDB 允许用这种方式来一次性地打印多个表达式的值：

(gdb) p {n, sum}
$6 = {1, 0}

 6) gdb -l 选项：列出源文件内容
为了搞清楚 while 语句的下一条语句的行号，我们需要列出源文件的内容，这需要使用l或者list命令： 
我们己经知道 while 语句之后是 return 语句，它的行号是 14，现在就可以用 b 命令设置一个新的断点：

(gdb) b 14 
Breakpoint 2 at 0x40051a: file main.c, line 14.

7) gdb -c 选项：继续执行程序
现在，可以用一个新的命令c或者continue来持续执行程序，直至遇到断点或者程序结束。因为己经设置断点，故程序将持续执行，在第 14 行处停下：

(gdb) c
Continuing.

Breakpoint 2, main () at main.c:14
14     return 0;

己经退出了 while 循环，说明累加过程己经成功结束，变量 sum 的值就是累加结果。我们来看看它到底是多少：

(gdb) p {n, sum}
$10 = {101, 5050}

 8) gdb -q 选项：退出调试
本次调试即将结束，我们可以先用 c 命令让程序“跑完全程”，然后再用q或者quit结束本次调试工作，这将使得调试器 GDB 结束运行并返回到操作系统：

(gdb) c
Continuing.
[Inferior 1 (process 2814) exited normally]
(gdb) q
[c.biancheng.net demo]$



*/